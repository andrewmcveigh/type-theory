* λ-calculus

type constants
type variables
type operators
type scheme (polytype?)

fix : /∀α((α -> α) -> α)/


Simply typed λ-calculus syntax
/e ::= x | e e' | λx:τ.e | c/

λ-calculus syntax
/e ::= x | e e' | λx.e/

HM language syntax
id | application | lambda | let
/e ::= x | e e' | λx.e | let x = e in e'/

** Untyped λ-calculus syntax

#+BEGIN_SRC clojure

(ns algorithm-w)

(require '[clojure.spec.alpha :as s])

(s/def ::exp
  (s/or ::var ::var
        ::app ::app
        ::abs ::abs
        ::let ::let))

(s/def ::var simple-symbol?)

(s/def ::app
  (s/cat :op ::exp :args (s/* ::exp)))

(s/def ::abs
  (s/cat :fn #{'fn} :arg (s/and vector? (s/cat :arg ::var)) :exp ::exp))

(s/def ::let
  (s/cat :let #{'let}
         :bin (s/and vector? (s/cat :var ::var :exp ::exp))
         :exp ::exp))

#+END_SRC

Assuming a set of /type-variables α/ and primitive types /ι/, the syntax of
types /τ/ and of /type-schemes σ/ is given by:

τ ::= α | ι | τ -> τ
σ ::= τ ∀ασ

A type-scheme ∀α₁...αₙτ has /generic/ type variables α₁...αₙ. A /monotype μ/ is
a type containing no type variables.

* Algorithm W

Unification is a recursive algorithm for determining a substitution of terms for
variables (i.e. a variable assignment) that makes two terms equal. For example
we can unify /f(a, y)/ with /f(x, f (b, x))/ with the substitution
/[a/x, f (b, a)/y]/ which should be read ‘substitute /a/ for /x/ and then
substitute /f(b, a)/ for /y/’.

The substitution /S/ is the composition /S = [ f (b, x)/y] ◦ [a/x]/ of the two
separate substitutions /[a/x]/ and /[f (b, x)/y]/. Note that composition of
substitutions is right to left so that we perform the rightmost first, and we
apply the rightmost to the leftmost in the process of composing. The order
matters. It is easy to see that the substitution /S/ applied to /f(a, y)/ gives
/f(a, f(b, a))/ and when applied to /f(x, f (b, x))/ yields the same. Thus we
say /S/ is a unifier of /f(a, y)/ and /f(x, f(b, x))/.

** Occurs check


#+BEGIN_SRC clojure
(defn occurs?
  "A variable `x` occurs in `term` if and only if `t = f(s[1],...s[n])` for
  `n > 0` and either `s[i] = x` or `x` occurs in `s[i]` for some
  `i = 1,2,...,n`"
  [x [t form :as term]]
  (case t
    ::app (or (occurs? x (:op form))
              (when (contains? form :args)
                (let [[[t' x' :as h] & more] (:args form)]
                  (or (and (= t' ::var) (= x x'))
                      (occurs? x h)
                      (and (seq more)
                           (occurs? x [::app (assoc form :args more)]))))))
    ::var (= x form)
    nil))

(comment

  (occurs? 'a (s/conform ::exp 'a))

  (occurs? 'a (s/conform ::exp '(f a)))

  (occurs? 'a (s/conform ::exp '((f a) b)))

  (occurs? 'a (s/conform ::exp '((f b) a)))

  (occurs? 'a (s/conform ::exp '((f b) b c d a)))

  (occurs? 'a (s/conform ::exp '((f b) (g b) (h c (i a)))))

  (occurs? 'a (s/conform ::exp '((f b) (g b) (h c (i d)))))

  )

#+END_SRC

#+BEGIN_SRC clojure
(defn substitute [l term]
  (if (empty? l)
    term
    (let [[t s] term]
      (case t
        ::var (let [[[t1 v1] & ss] l]
                (if (= s v1) t1 (substitute ss term)))
        ::app (if-let [args (:args s)]
                [::app (assoc s :args (map (partial substitute l) args))]
                term)))))

(comment

  (substitute '{int? a} (s/conform ::exp 'a))

  (substitute '{int? a} (s/conform ::exp '(f a)))

  (substitute '{int? a} (s/conform ::exp '(f b)))

  (substitute '{int? a} (s/conform ::exp '((f b) (g b) (h c (i a)))))

  (substitute '{int? a} (s/conform ::exp '((f b) (g b) (h c (i d)))))

  )

#+END_SRC

#+BEGIN_SRC sml
fun compose [] s1 = s1
  | compose (s::ss) s1 =
      let fun iter r s [] = rev r
            | iter r s ((t1,v1)::ss) =
                iter (((subs [s] t1),v1)::r) s ss
      in
        compose ss (s::(iter [] s s1))
      end
#+END_SRC

#+BEGIN_SRC clojure

(defn compose
  "Composition of lists of substitutions.
   The substitution `S` is the composition `S = [f(b,x)/y] ◦ [a/x]` of the two
   separate substitutions `[a/x]` and `[f(b,x)/y]`. Note that composition of
   substitutions is right to left so that we perform the rightmost first, and we
   apply the rightmost to the leftmost in the process of composing. The order
   matters. It is easy to see that the substitution `S` applied to `f(a,y)`
   gives `f(a,f(b,a))` and when applied to `f(x,f(b,x))` yields the same. Thus
   we say `S` is a unifier of `f(a,y)` and `f(x,f(b,x))`."
  [s s1]
  (if (empty? s)
    s1
    (let [iter (fn iter [r s ss]
                 (if (seq ss)
                   (let [[[t1 v1] & ss'] ss]
                     (iter (conj r [(substitute [s] t1) v1])
                           s
                           ss'))
                   r))
          [s & ss] s]
      (compose ss (cons s (iter [] s s1))))))

(defn unify-ex [s]
  (throw (ex-info s {:type :unify})))

#+END_SRC

#+BEGIN_SRC clojure

(declare unify*)

(defn unify-args [acc args1 args2]
  (cond (and (empty? args1) (empty? args2))
        acc
        (= (count args1) (count args2))
        (let [[t1 & t1s] args1
              [t2 & t2s] args2]
          (recur (compose (unify* []
                                  (substitute acc t1)
                                  (substitute acc t2))
                          acc)
                 t1s
                 t2s))
        :else (unify-ex "Arity")))

(defn unify* [acc [t v :as t1] [t' v' :as t2]]
  (case [t t']
    [::var ::var] (if (= v v') [] (cons [t1 v'] acc))
    [::var ::app] (if (empty? (:args v'))
                    (cons [t2 v] acc)
                    (if (occurs? v t2)
                      (unify-ex "Occurs")
                      (cons [t2 v] acc)))
    [::app ::var] (if (empty? (:args v))
                    (cons [t1 v'] acc)
                    (if (occurs? v' t1)
                      (unify-ex "Occurs")
                      (cons [t1 v'] acc)))
    [::app ::app] (let [{name1 :op args1 :args} v
                        {name2 :op args2 :args} v']
                    (if (= name1 name2)
                      (unify-args acc args1 args2)
                      (unify-ex "Const")))))

(defn unify
  "To find the most general unifier `U = MGU(t,t')` of terms `t` and `t`:
      (i) If `t = x` and `t' = y` then `U = [x/y]`
    (iia) If `t = x` and `t' = f(s[1],s[2],...,s[n])` and `x` does not occur in
          `t'` then `U = [t'/x]`
    (iib) If `t = f(s[1],s[2],...,s[n])` and `t' = x` and `x` does not occur in
          `t` then `U = [t/x]`
    (iii) If `t = a` and `t' = a` then `U = []`
     (iv) If `t = f(s[1],s[2],...,s[n])` and `t' = f(s[1],s[2],...,s[n])` then
          `U = MGU( f(U[1]s[2],U[1]s[3],...,s[n])
                  , f(U[1]s[2]',U[1]s[3]',...,s[n])) ◦ U[1]`
           where `U[1] = MGU(s[1]',s[1]')
  In any other circumstances the algorithm fails"
  [t1 t2]
  (unify* () t1 t2))

(comment

  (= (unify (s/conform ::exp 'x) (s/conform ::exp 'y))
     '([[:algorithm-w/var x] y]))

  (= (unify (s/conform ::exp 'x) (s/conform ::exp '(f s' s'')))
     '([[:algorithm-w/app
         {:op [:algorithm-w/var f],
          :args [[:algorithm-w/var s'] [:algorithm-w/var s'']]}]
        x]))

  (= (unify (s/conform ::exp '(f s' s'')) (s/conform ::exp 'x))
     '([[:algorithm-w/app
         {:op [:algorithm-w/var f],
          :args [[:algorithm-w/var s'] [:algorithm-w/var s'']]}] x]))

  (= (unify (s/conform ::exp 'a) (s/conform ::exp 'a)) [])

  )


#+END_SRC

The Hindley-Milner Type Inference Algorithm
Ian Grant∗
January 17, 2011
http://steshaw.org/hm/hindley-milner.pdf
