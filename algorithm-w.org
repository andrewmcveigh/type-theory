* λ-calculus

type constants
type variables
type operators
type scheme (polytype?)

fix : /∀α((α -> α) -> α)/


Simply typed λ-calculus syntax
/e ::= x | e e' | λx:τ.e | c/

λ-calculus syntax
/e ::= x | e e' | λx.e/

HM language syntax
id | application | lambda | let
/e ::= x | e e' | λx.e | let x = e in e'/

** Untyped λ-calculus syntax

#+begin_src clojure :tangle yes
(ns algorithm-w
  (:require [clojure.spec.alpha :as s]))

(s/def ::exp
  (s/or ::var ::var
        ::app ::app
        ::abs ::abs
        ::let ::let))

(s/def ::var simple-symbol?)

(s/def ::app
  (s/cat :op ::exp :args (s/* ::exp)))

(s/def ::abs
  (s/cat :fn #{'fn} :arg (s/and vector? (s/cat :arg ::var)) :exp ::exp))

(s/def ::let
  (s/cat :let #{'let}
         :bin (s/and vector? (s/cat :var ::var :exp ::exp))
         :exp ::exp))
#+end_src

Assuming a set of /type-variables α/ and primitive types /ι/, the syntax of
types /τ/ and of /type-schemes σ/ is given by:

τ ::= α | ι | τ -> τ
σ ::= τ ∀ασ

A type-scheme ∀α₁...αₙτ has /generic/ type variables α₁...αₙ. A /monotype μ/ is
a type containing no type variables.

* Algorithm W

Unification is a recursive algorithm for determining a substitution of terms for
variables (i.e. a variable assignment) that makes two terms equal. For example
we can unify /f(a, y)/ with /f(x, f (b, x))/ with the substitution
/[a/x, f (b, a)/y]/ which should be read ‘substitute /a/ for /x/ and then
substitute /f(b, a)/ for /y/’.

The substitution /S/ is the composition /S = [f(b,x)/y] ◦ [a/x]/ of the two
separate substitutions /[a/x]/ and /[f(b,x)/y]/. Note that composition of
substitutions is right to left so that we perform the rightmost first, and we
apply the rightmost to the leftmost in the process of composing. The order
matters. It is easy to see that the substitution /S/ applied to /f(a, y)/ gives
/f(a, f(b, a))/ and when applied to /f(x, f (b, x))/ yields the same. Thus we
say /S/ is a unifier of /f(a, y)/ and /f(x, f(b, x))/.

** Occurs check


#+begin_src clojure :tangle yes
(defn occurs?
  "A variable `x` occurs in `term` if and only if `t = f(s[1],...s[n])` for
  `n > 0` and either `s[i] = x` or `x` occurs in `s[i]` for some
  `i = 1,2,...,n`"
  [x [t form]]
  (case t
    ::app
    (or (occurs? x (:op form))
        (when (contains? form :args)
          (let [[[t' x' :as h] & more] (:args form)]
            (or (and (= t' ::var) (= x x'))
                (occurs? x h)
                (and (seq more)
                     (occurs? x [::app (assoc form :args more)]))))))
    ::var
    (= x form)
    nil))
#+end_src

#+begin_src clojure
(defn substitute [coll term]
  (if (empty? coll)
    term
    (let [[t s] term]
      (case t
        ::var
        (let [[[t1 v1] & ss] coll]
          (if (= s v1) t1 (substitute ss term)))
        ::app
        (if-let [args (:args s)]
          [::app (assoc s :args (map (partial substitute coll) args))]
          term)))))
#+end_src

** Substitution composition
   The substitution /S/ is the composition /S = [f(b,x)/y] ◦ [a/x]/ of the two
   separate substitutions /[a/x]/ and /[f(b,x)/y]/. Note that composition of
   substitutions is right to left so that we perform the rightmost first, and we
   apply the rightmost to the leftmost in the process of composing. The order
   matters. It is easy to see that the substitution /S/ applied to /f(a,y)/
   gives /f(a,f(b,a))/ and when applied to /f(x,f(b,x))/ yields the same. Thus
   we say /S/ is a unifier of /f(a,y)/ and /f(x,f(b,x))/.

#+begin_src clojure
(defn compose [s s1]
  (if (empty? s)
    s1
    (let [iter (fn iter [r s ss]
                 (if (seq ss)
                   (let [[[t1 v1] & ss'] ss]
                     (iter (conj r [(substitute [s] t1) v1])
                           s
                           ss'))
                   r))
          [s & ss] s]
      (compose ss (cons s (iter [] s s1))))))

#+end_src

** Unification

   To find the most general unifier `U = MGU(t,t')` of terms `t` and `t`:

      (i) If `t = x` and `t' = y` then `U = [x/y]`
    (iia) If `t = x` and `t' = f(s[1],s[2],...,s[n])` and `x` does not occur in
          `t'` then `U = [t'/x]`
    (iib) If `t = f(s[1],s[2],...,s[n])` and `t' = x` and `x` does not occur in
          `t` then `U = [t/x]`
    (iii) If `t = a` and `t' = a` then `U = []`
     (iv) If `t = f(s[1],s[2],...,s[n])` and `t' = f(s[1],s[2],...,s[n])` then
          `U = MGU( f(U[1]s[2],U[1]s[3],...,s[n])
                  , f(U[1]s[2]',U[1]s[3]',...,s[n])) ◦ U[1]`
           where `U[1] = MGU(s[1]',s[1]')

   In any other circumstances the algorithm fails

#+begin_src clojure
(defn unify-ex [s]
  (throw (ex-info s {:type :unify})))

(declare unify*)

(defn unify-args [acc args1 args2]
  (cond (and (empty? args1) (empty? args2))
        acc
        (= (count args1) (count args2))
        (let [[t1 & t1s] args1
              [t2 & t2s] args2]
          (recur (compose (trampoline unify* []
                                      (substitute acc t1)
                                      (substitute acc t2))
                          acc)
                 t1s
                 t2s))
        :else (unify-ex "Arity")))

(defmulti unify* (fn [_ [t] [t']] [t t']))

(defmethod unify* [::var ::var]
  [acc [_ v :as t1] [_ v' :as t2]]
  (if (= v v')
    []
    (cons [t1 v'] acc)) )

(defmethod unify* [::var ::app]
  [acc [_ v :as t1] [_ v' :as t2]]
  (if (empty? (:args v'))
    (cons [t2 v] acc)
    (if (occurs? v t2)
      (unify-ex "Occurs")
      (cons [t2 v] acc))))

(defmethod unify* [::app ::var]
  [acc [_ v :as t1] [_ v' :as t2]]
  (if (empty? (:args v))
    (cons [t1 v'] acc)
    (if (occurs? v' t1)
      (unify-ex "Occurs")
      (cons [t1 v'] acc))))

(defmethod unify* [::app ::app]
  [acc [_ {name1 :op args1 :args}] [_ {name2 :op args2 :args}]]
  (if (= name1 name2)
    (trampoline unify-args acc args1 args2)
    (unify-ex "Const")))

(defn unify
  "To find the most general unifier `U = MGU(t,t')` of terms `t` and `t`:
      (i) If `t = x` and `t' = y` then `U = [x/y]`
    (iia) If `t = x` and `t' = f(s[1],s[2],...,s[n])` and `x` does not occur in
          `t'` then `U = [t'/x]`
    (iib) If `t = f(s[1],s[2],...,s[n])` and `t' = x` and `x` does not occur in
          `t` then `U = [t/x]`
    (iii) If `t = a` and `t' = a` then `U = []`
     (iv) If `t = f(s[1],s[2],...,s[n])` and `t' = f(s[1],s[2],...,s[n])` then
          `U = MGU( f(U[1]s[2],U[1]s[3],...,s[n])
                  , f(U[1]s[2]',U[1]s[3]',...,s[n])) ◦ U[1]`
           where `U[1] = MGU(s[1]',s[1]')
  In any other circumstances the algorithm fails"
  [t1 t2]
  (unify* () t1 t2))
#+end_src

** Algorithm W
W(Γ,e)=(S,τ) where

The Hindley-Milner Type Inference Algorithm
Ian Grant∗
January 17, 2011
http://steshaw.org/hm/hindley-milner.pdf
