* λ-calculus

type constants
type variables
type operators
type scheme (polytype?)

fix : /∀α((α -> α) -> α)/


Simply typed λ-calculus syntax
/e ::= x | e e' | λx:τ.e | c/

λ-calculus syntax
/e ::= x | e e' | λx.e/

HM language syntax
id | application | lambda | let
/e ::= x | e e' | λx.e | let x = e in e'/

** Untyped λ-calculus syntax

#+BEGIN_SRC clojure

(require '[clojure.spec.alpha :as s])

(s/def ::exp
  (s/or ::var ::var
        ::app ::app
        ::abs ::abs
        ::let ::let))

(s/def ::var simple-symbol?)

(s/def ::app
  (s/cat :op ::exp :args (s/* ::exp)))

(s/def ::abs
  (s/cat :fn #{'fn} :arg (s/and vector? (s/cat :arg ::var)) :exp ::exp))

(s/def ::let
  (s/cat :let #{'let}
         :bin (s/and vector? (s/cat :var ::var :exp ::exp))
         :exp ::exp))

#+END_SRC

Assuming a set of /type-variables α/ and primitive types /ι/, the syntax of
types /τ/ and of /type-schemes σ/ is given by:

τ ::= α | ι | τ -> τ
σ ::= τ ∀ασ

A type-scheme ∀α₁...αₙτ has /generic/ type variables α₁...αₙ. A /monotype μ/ is
a type containing no type variables.

* Algorithm W

Unification is a recursive algorithm for determining a substitution of terms for
variables (i.e. a variable assignment) that makes two terms equal. For example
we can unify /f(a, y)/ with /f(x, f (b, x))/ with the substitution
/[a/x, f (b, a)/y]/ which should be read ‘substitute /a/ for /x/ and then
substitute /f(b, a)/ for /y/’.

The substitution /S/ is the composition /S = [ f (b, x)/y] ◦ [a/x]/ of the two
separate substitutions /[a/x]/ and /[f (b, x)/y]/. Note that composition of
substitutions is right to left so that we perform the rightmost first, and we
apply the rightmost to the leftmost in the process of composing. The order
matters. It is easy to see that the substitution /S/ applied to /f(a, y)/ gives
/f(a, f(b, a))/ and when applied to /f(x, f (b, x))/ yields the same. Thus we
say /S/ is a unifier of /f(a, y)/ and /f(x, f(b, x))/.

** Occurs check


#+BEGIN_SRC clojure
(defn occurs?
  "A variable `x` occurs in `term` if and only if `t = f(s[1],...s[n])` for
  `n > 0` and either `s[i] = x` or `x` occurs in `s[i]` for some
  `i = 1,2,...,n`"
  [x [t form :as term]]
  (case t
    ::app (or (occurs? x (:op form))
              (when (contains? form :args)
                (let [[[t' x' :as h] & more] (:args form)]
                  (or (and (= t' ::var) (= x x'))
                      (occurs? x h)
                      (and (seq more)
                           (occurs? x [::app (assoc form :args more)]))))))
    ::var (= x form)
    nil))

(comment

  (occurs? 'a (s/conform ::exp 'a))

  (occurs? 'a (s/conform ::exp '(f a)))

  (occurs? 'a (s/conform ::exp '((f a) b)))

  (occurs? 'a (s/conform ::exp '((f b) a)))

  (occurs? 'a (s/conform ::exp '((f b) b c d a)))

  (occurs? 'a (s/conform ::exp '((f b) (g b) (h c (i a)))))

  (occurs? 'a (s/conform ::exp '((f b) (g b) (h c (i d)))))

  )

#+END_SRC

#+BEGIN_SRC clojure
(defn substitute [l term]
  (if (empty? l)
    term
    (let [[t s] term]
      (case t
        ::var (let [[[t1 v1] & ss] l]
                (if (= s v1) t1 (substitute ss term)))
        ::app (if-let [args (:args s)]
                (letfn [(arglist [r xs]
                          (if (empty? xs)
                            (reverse r)
                            (let [[h & t] xs]
                              (arglist (cons (substitute l h) r) t))))]
                  [::app (assoc s :args (arglist [] args))])
                term)))))

#+END_SRC

#+BEGIN_SRC sml
fun subs [] term = term
  | subs ((t1,v1)::ss) (term as Tyvar name) =
      if name=v1 then t1 else subs ss term
  | subs _ (term as Tyapp(name,[])) = term
  | subs l (Tyapp(name,args)) =
      let fun arglist r [] = rev r
            | arglist r (h::t) =
                arglist ((subs l h)::r) t
      in
        Tyapp(name, arglist [] args)
      end
#+END_SRC

#+BEGIN_SRC sml
fun compose [] s1 = s1
  | compose (s::ss) s1 =
      let fun iter r s [] = rev r
            | iter r s ((t1,v1)::ss) =
                iter (((subs [s] t1),v1)::r) s ss
      in
        compose ss (s::(iter [] s s1))
      end
#+END_SRC

#+BEGIN_SRC clojure

(defn compose
  "Composition of lists of substitutions"
  [s s1]
  (if (empty? s)
    s1
    (let [iter (fn [r s ss]
                 (if (seq ss)
                   (let [[[t1 v1] & ss'] ss]
                     (iter (conj r [(substitute [s] t1) v1])
                           s
                           ss'))
                   r))
          [s & ss] s]
      (prn s ss)
      (compose ss (cons s (iter [] s s1))))))

(compose '[a] '[a])

(defn unify-ex [s]
  (throw (ex-info s {:type :unify})))

#+END_SRC

#+BEGIN_SRC clojure

(defn unify-args [r t1s t2s])

#+END_SRC

#+BEGIN_SRC sml
fun unify_args r [] [] = rev r
  | unify_args r [] _ = raise Unify "Arity"
  | unify_args r _ [] = raise Unify "Arity"
  | unify_args r (t1::t1s) (t2::t2s) =
      unify_args (compose (iter [] (subs r t1) (subs r t2)) r) t1s t2s
#+END_SRC

The Hindley-Milner Type Inference Algorithm
Ian Grant∗
January 17, 2011
http://steshaw.org/hm/hindley-milner.pdf
